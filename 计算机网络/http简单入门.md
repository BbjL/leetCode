### HTTP基本认识
超文本传输协议

##### HTTP/0.9
- 只有一种请求方式GET请求
- 服务器发送完毕数据就会关闭TCP链接
- 协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。


##### HTTP/1.0
- 加入请求响应头header，描述元信息
- 增加POST HEAD请求方法
- 可以发送任何格式的内容
- 每个TCP请求只能发送一个请求

##### HTTP/1.1
- 支持长连接（不用声明Connection: keep-alive，也可以在客户端在最后一个请求时，发送Connection: close）
- 管道机制**pipelining**
    >   特点：将多个HTTP请求放入一个TCP连接中，同时发送，虽然可以同时发送，但是响应时还是要等待上一个请求响应，因此容易产生队头阻塞。  
    缺点：会出现队头阻塞，如果上一个请求超时，那么后面的全部请求都需要重新发送，因此绝大部分浏览器都会默认关闭该功能。
- Content-length字段
    > 一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。  
    如Content-Length: 3495，上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。
    在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。
- 分块传输编码
    > 使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。  
    但是对于动态操作，需要等服务器将所有操作完成，才能发送数据长度，显然这样效率不高。  
    更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。  
    因此，1.1版规定可以不使用Content-Length字段，而使用"分块传输编码"（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。  
    字段：Transfer-Encoding: chunked  
    每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了
- 新增PUT、PATCH、HEAD、 OPTIONS、DELETE
- 新增host字段，用来指定服务器的域名

##### HTTP/2.0
- 完全的二进制协议
    > HTTP1.0头部采用的是文本（ASCII编码），2.0采用的是完全的二进制协议，头部信息，数据体都是采用二进制传输，并且统称为“帧”，头部信息帧，数据帧。  
- 多共（双向实时通信）
    > HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。  
    ========================== 
    举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。  
    这样双向的、实时的通信，就叫做多工（Multiplexing）。

- 数据流
    > 因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。  
    HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。  
    数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。  
    客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。
- 头部信息压缩
    > HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。  
    HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
- 服务器推送
    > HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。   
    常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

- 优点
    > 1、同域名下的所有通信都在同一个连接中进行，只需要占用一个TCP链接  
    2、单个连接可以承载任意数量的双向数据流。
    3、数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。  
    3、主动向客户端发送资源，不需要再页面解析完之后再请求资源，服务器可以提前推送
    4、头部压缩，HTTP/1.1频繁发送相同的头部信息，HTTP/2可以采用压缩和客户端服务器共同维护的头信息表方式极大减少发送相同的头部信息



##### 问题
二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多
二进制为什么会比文本容易解析？？？？？
答：采用二进制分帧进行传输，可以标示每个数据流，对不断传输过来的数据包，可以通过首帧的标示进行重组，从而不需要考虑传送过来的顺序

###### 状态码
状态码： 状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值，如下：

1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。

100 Continue
101 Switching Protocols
2xx：成功状态码，表示服务器已成功接收到请求并进行处理。
200 OK 表示客户端请求成功

204 No Content 成功，但不返回任何实体的主体部分
206 Partial Content 成功执行了一个范围（Range）请求
3xx：重定向状态码，表示服务器要求客户端重定向。

301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL
302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源
303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源
304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存
307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现
4xx：客户端错误状态码，表示客户端的请求有非法内容。

400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解
401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用
403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因
404 Not Found 请求的资源不存在，例如，输入了错误的URL
5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。

500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求
503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常
504 请求超时

参考连接
[HTTP 协议入门](http://www.ruanyifeng.com/blog/2016/08/http.html)
[HTTP/2的优点](https://zhuanlan.zhihu.com/p/26559480)